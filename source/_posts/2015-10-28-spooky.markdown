---
layout: post
title: "Spooky"
date: 2015-10-28 18:22:54 -0400
comments: true
categories: Flatiron School
---
This week I was introduced to Rails, and there has been a whirlwind of new information and abstractions. 

While working on a lab, there was a problem that was particularly illuminating on how Rails abstracts away code that the programmer would otherwise have to write themselves in Ruby. 

The lab asked the engineer to build a blog with many Posts, which could have multiple tags. Each tag had to have a unique name and the user should be able to create their own unique tag.

I was able to add collection_check_boxes to my Post form (which in itself is an awesome abstraction). 

  ```ruby
  <%= f.collection_check_boxes :tag_ids, Tag.all, :id, :name %>
  ```

The next step was to add a text_field at the end of this list of tags, in order to allow the user the opportunity to generate their own unique tag for their Post by adding a field_for Tags form to my form_for Post. 

  ```ruby 
  <%= f.fields_for :tags, Tag.new do |tags_form| %>
      <li>
        <%= tags_form.label :name %>
        <%= tags_form.text_field :name %>
      </li>
  <% end %>
  ```
  However...when I launched up the server and created a new post whose tags exclusively included preexisting ones I got this:

  <img src="../images/empty_string.png" height="150" width="150">

  D'oh, my Tag name was passed into the unordered list on the Posts show page. 

  So I started to troubleshoot the bug by adding a raise in the create action of my PostsController in order to see the paramaters that were being returned: 

  ```ruby
    class PostsController
      def create
        raise
        @post = Post.new(post_params)
      end
    end
  ```

  ```ruby
    "post"=>{"name"=>"bbq", "content"=>"healthy living", "tag_ids"=>["2", "13", ""], "tags_attributes"=>{"0"=>{"name"=>""}}}, "commit"=>"Create Post", "controller"=>"posts", "action"=>"create"
  ```

  And there it is! tags_attributes is passing {name => ""}.

  My first reaction was to write a method that would serve as validation for a Tag's name along the lines of this:  

  ```ruby
    def empty_name(post_attr)
      post_attr.hash.map do |label, name_hash|
        name_hash.delete_if{|label, name| name == ""}
      end
    end
  ```

  But, if the point of Rails is convention over configuration, the framework should provide a method that would make this much easier.

  The first thing that the google-machine returned for me was a reject_if clause that would go in toPost model: 

  ```ruby
    class Post
      accepts_nested_attributes_for :tags, reject_if: proc { |attributes| attributes[:name].blank? }
    end
  ```

  Amazing! I actually used a Proc! But, to me this isn't super readable. 

  So the second way of skining this cat was to create a private method in my Post model that I could call on: 

  ```ruby
    class Post
      accepts_nested_attributes_for :tags reject_if: :blank_name?
      
      private
      
      def blank_name?(attribute)
        attribute['name'].blank?
      end
    end
  ```

  This is nice and readable and is hiding a lot behind the scenes. Which isn't necessarily a good thing. 

  The third solution that I thought of to solve this problem was to write out a tag_attributes=() method myself, thereby replacing the accepts_nested_attributes_for. 

    ```ruby
      class Post
        #attributes = {"tag_1"=>{"name"=>"WW1"}, "tag_2"=>{"name"=>"WW2"}, "tag_3"=>""}
        private

        def courses_attributes=(attributes)
          attributes.each do |tag_hash|
            self.courses.build(tag_hash) if tag_hash[:name].present?
          end
        end
      end
    ```

  The amazing thing about programming is that it involves a lot of creativity and decision making. This problem was a great example to me of how one problem could be solved in many different ways, each with pros and cons. It is extremely valuable to someone like myself, who is new to Ruby on Rails, to learn from trial by fire. By experimenting as much as I can, and by attempting to explore the pros and cons of every solution I am helping myself to recognize patterns in the future, thereby making it easier to debug future applications. 
